using System;
using System.Collections.Concurrent;
using System.Security.Cryptography;
using JetBrains.Annotations;

namespace Scalider.Security
{

    /// <summary>
    /// Computes the Cyclic Redundancy Check (CRC) hash for the input data.
    /// </summary>
    public sealed partial class Crc : HashAlgorithm
    {

        private static readonly ConcurrentDictionary<string, ulong[]> LookupTableCache =
            new ConcurrentDictionary<string, ulong[]>();

        private readonly CrcParameters _parameters;
        private ulong _hash;

        /// <summary>
        /// Initializes a new instance of the <see cref="Crc"/> class.
        /// </summary>
        /// <param name="parameters"></param>
        private Crc([NotNull] CrcParameters parameters)
        {
            Check.NotNull(parameters, nameof(parameters));

            _parameters = parameters;
            LookupTable = GetOrCreateLookupTable(parameters);
        }

        /// <summary>
        /// Gets a value indicating the lookup table generated by the given parameters.
        /// </summary>
        [UsedImplicitly]
        public ulong[] LookupTable { get; }

        /// <inheritdoc />
        public override void Initialize() => _hash = _parameters.ReflectOut
            ? ReflectBits(_parameters.InitialValue, 32)
            : _parameters.InitialValue;

        /// <inheritdoc />
        protected override void HashCore(byte[] array, int ibStart, int cbSize)
        {
            ulong hash = _parameters.InitialValue;
            if (_parameters.ReflectIn)
                hash = ReflectBits(hash, _parameters.Width);

            // Calculate hash
            for (int i = ibStart; i < ibStart + cbSize; i++)
            {
                ulong b = array[i];
                hash = _parameters.ReflectIn
                    ? LookupTable[(hash ^ b) & 0xff] ^ (hash >> 8)
                    : LookupTable[((hash >> (_parameters.Width - 8)) ^ b) & 0xff] ^ (hash << 8);

                hash &= uint.MaxValue >> 32;
            }

            // Source: https://stackoverflow.com/a/28661073
            // Per Mark Adler - ...the reflect out different from the reflect in (CRC-12/3GPP).
            // In that one case, you need to bit reverse the output since the input is not reflected,
            // but the output is.
            if (_parameters.ReflectIn ^ _parameters.ReflectOut)
                hash = ReflectBits(hash, _parameters.Width);

            // Done
            _hash = hash;
        }

        /// <inheritdoc />
        protected override byte[] HashFinal()
        {
            var hashBuffer = ToBigEndianBytes(_hash ^ _parameters.XorOutValue);

            var leftover = _parameters.Width / hashBuffer.Length;
            var newHashBuffer = new byte[leftover];
            Array.Copy(hashBuffer, hashBuffer.Length - leftover, newHashBuffer, 0, leftover);
            hashBuffer = newHashBuffer;

            // Done
            HashValue = hashBuffer;
            return hashBuffer;
        }

        /// <summary>
        /// Creates an instance of the default implementation of the <see cref="Crc"/> hash algorithm.
        /// </summary>
        /// <returns>
        /// A new instance of the <see cref="Crc"/>.
        /// </returns>
        public new static Crc Create()
            => new Crc(CrcAlgorithmParameters[CrcAlgorithmNames.CRC32]);

        /// <summary>
        /// Creates an instance of the specified implementation of the <see cref="Crc"/> hash algorithm.
        /// </summary>
        /// <param name="algorithmName">The name of the specific implementation of <see cref="Crc"/> to use.</param>
        /// <returns>
        /// A new instance of the specified implementation of <see cref="Crc"/>.
        /// </returns>
        public new static Crc Create(string algorithmName)
        {
            Check.NotNullOrEmpty(algorithmName, nameof(algorithmName));
            if (!CrcAlgorithmParameters.TryGetValue(algorithmName, out var parameters) ||
                parameters == null)
            {
                // Unknown algorithm or the algorithm parameters haven't been defined
                throw new ArgumentException(
                    $"No algorithm with the name \"{algorithmName}\" could be found.",
                    nameof(algorithmName)
                );
            }

            // Done
            return new Crc(parameters);
        }

        private static byte[] ToBigEndianBytes(ulong i)
        {
            var result = BitConverter.GetBytes(i);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);

            return result;
        }

        private static ulong[] GetOrCreateLookupTable(CrcParameters p)
        {
            int refIn = p.ReflectIn ? 1 : 0;
            int refOut = p.ReflectOut ? 1 : 0;

            var cacheKey = $"{p.Width}:{p.Polynomial}{p.InitialValue}{p.XorOutValue}{refIn}{refOut}";
            return LookupTableCache.GetOrAdd(
                cacheKey,
                t =>
                {
                    var lookupTable = new ulong[256];
                    var topBit = (ulong)1 << (p.Width - 1);

                    // Calculate lookup table
                    for (var i = 0; i < lookupTable.Length; i++)
                    {
                        var r = (ulong)i;
                        if (p.ReflectIn)
                            r = ReflectBits(r, p.Width);
                        else if (p.Width > 8)
                            r <<= p.Width - 8;

                        //var r = (ulong)inByte << (width - 8);
                        for (var j = 0; j < 8; j++)
                            r = (r & topBit) != 0 ? (r << 1) ^ p.Polynomial : r << 1;

                        if (p.ReflectIn)
                            r = ReflectBits(r, p.Width);

                        lookupTable[i] = r & (ulong.MaxValue >> (64 - p.Width));
                    }

                    // Done
                    return lookupTable;
                }
            );
        }

        /// <summary>
        /// Reflects the bits of a provided numeric value.
        /// </summary>
        /// <param name="b">Value to reflect the bits of.</param>
        /// <param name="bitCount">Number of bits in the provided value.</param>
        /// <returns>
        /// Bit-reflected version of the provided numeric value.
        /// </returns>
        private static ulong ReflectBits(ulong b, int bitCount)
        {
            ulong reflection = 0x00;
            for (var bitNumber = 0; bitNumber < bitCount; ++bitNumber)
                if (((b >> bitNumber) & 0x01) == 0x01)
                    reflection |= (ulong)1 << (bitCount - 1 - bitNumber);

            return reflection;
        }

    }

}